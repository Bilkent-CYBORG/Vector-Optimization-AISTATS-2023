{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Imports\n",
    "\n",
    "%matplotlib inline\n",
    "import matplotlib\n",
    "matplotlib.rcParams['text.usetex'] = True\n",
    "matplotlib.rcParams.update({'font.size': 14})\n",
    "import matplotlib.pyplot as plt\n",
    "plt.style.use('seaborn-whitegrid')\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import cvxpy as cp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Load data\n",
    "\n",
    "datafile = 'sort_256.csv'\n",
    "designs = np.genfromtxt(datafile, delimiter=';')\n",
    "mu = np.copy(designs[:,3:])\n",
    "mu[:,0] = -mu[:,0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Helper functions\n",
    "\n",
    "def get_bigmij(vi, vj, W):\n",
    "    \"\"\"\n",
    "    Compute M(i,j) for designs i and j \n",
    "    :param vi, vj: (D,1) ndarrays\n",
    "    :param W: (n_constraint,D) ndarray\n",
    "    :return: M(i,j).\n",
    "    \"\"\"\n",
    "    D = W.shape[1]\n",
    "    P = 2*np.eye(D)\n",
    "    q = (-2*(vj-vi)).ravel()\n",
    "    G = -W\n",
    "    h = -np.array([np.max([0,np.dot(W[0,:],vj-vi)[0]]),\n",
    "                np.max([0,np.dot(W[1,:],vj-vi)[0]])])\n",
    "\n",
    "    # Define and solve the CVXPY problem.\n",
    "    x = cp.Variable(D)\n",
    "    prob = cp.Problem(cp.Minimize((1/2)*cp.quad_form(x, P) + q.T @ x),\n",
    "                 [G @ x <= h])\n",
    "    #A @ x == b    \n",
    "    prob.solve()\n",
    "    bigmij = np.sqrt(prob.value + np.dot((vj-vi).T, vj-vi)).ravel()\n",
    "\n",
    "    # Print result.\n",
    "    #print(\"\\nThe optimal value is\", prob.value)\n",
    "    #print(\"A solution x is\")\n",
    "    #print(x.value)\n",
    "    #print(\"A dual solution corresponding to the inequality constraints is\")\n",
    "    #print(prob.constraints[0].dual_value)\n",
    "    #print(\"M(i,j) is\", bigmij)\n",
    "    return bigmij\n",
    "\n",
    "\n",
    "def get_alpha(rind, W):\n",
    "    \"\"\"\n",
    "    Compute alpha_rind for row rind of W \n",
    "    :param rind: row index\n",
    "    :param W: (n_constraint,D) ndarray\n",
    "    :return: alpha_rind.\n",
    "    \"\"\"\n",
    "    m = W.shape[0]+1 #number of constraints\n",
    "    D = W.shape[1]\n",
    "    f = -W[rind,:]\n",
    "    A = []\n",
    "    b = []\n",
    "    c = []\n",
    "    d = []\n",
    "    for i in range(W.shape[0]):\n",
    "        A.append(np.zeros((1, D)))\n",
    "        b.append(np.zeros(1))\n",
    "        c.append(W[i,:])\n",
    "        d.append(np.zeros(1))\n",
    "    \n",
    "    A.append(np.eye(D))\n",
    "    b.append(np.zeros(D))\n",
    "    c.append(np.zeros(D))\n",
    "    d.append(np.ones(1))\n",
    "\n",
    "    # Define and solve the CVXPY problem.\n",
    "    x = cp.Variable(D)\n",
    "    # We use cp.SOC(t, x) to create the SOC constraint ||x||_2 <= t.\n",
    "    soc_constraints = [\n",
    "          cp.SOC(c[i].T @ x + d[i], A[i] @ x + b[i]) for i in range(m)\n",
    "    ]\n",
    "    prob = cp.Problem(cp.Minimize(f.T@x),\n",
    "                  soc_constraints)\n",
    "    prob.solve()\n",
    "\n",
    "    \"\"\"\n",
    "    # Print result.\n",
    "    print(\"The optimal value is\", -prob.value)\n",
    "    print(\"A solution x is\")\n",
    "    print(x.value)\n",
    "    for i in range(m):\n",
    "        print(\"SOC constraint %i dual variable solution\" % i)\n",
    "        print(soc_constraints[i].dual_value)\n",
    "    \"\"\"    \n",
    "        \n",
    "    return -prob.value   \n",
    "\n",
    "\n",
    "def get_alpha_vec(W):\n",
    "    \"\"\"\n",
    "    Compute alpha_vec for W \n",
    "    :param W: an (n_constraint,D) ndarray\n",
    "    :return: alpha_vec, an (n_constraint,1) ndarray\n",
    "    \"\"\"    \n",
    "    alpha_vec = np.zeros((W.shape[0],1))\n",
    "    for i in range(W.shape[0]):\n",
    "        alpha_vec[i] = get_alpha(i, W)\n",
    "    return alpha_vec\n",
    "\n",
    "\n",
    "def get_smallmij(vi, vj, W, alpha_vec):\n",
    "    \"\"\"\n",
    "    Compute m(i,j) for designs i and j \n",
    "    :param vi, vj: (D,1) ndarrays\n",
    "    :param W: (n_constraint,D) ndarray\n",
    "    :param alpha_vec: (n_constraint,1) ndarray of alphas of W\n",
    "    :return: m(i,j).\n",
    "    \"\"\"    \n",
    "    prod = np.matmul(W, vj - vi)\n",
    "    prod[prod<0] = 0\n",
    "    smallmij = (prod/alpha_vec).min()\n",
    "    \n",
    "    return smallmij  \n",
    "\n",
    "\n",
    "def is_covered_SOCP(vi, vj, eps, W):\n",
    "    \"\"\"\n",
    "    Check if vi is eps covered by vj for cone matrix W \n",
    "    :param vi, vj: (D,1) ndarrays\n",
    "    :param W: An (n_constraint,D) ndarray\n",
    "    :param eps: float\n",
    "    :return: Boolean.\n",
    "    \"\"\"    \n",
    "    m = 2*W.shape[0]+1 # number of constraints\n",
    "    D = W.shape[1]\n",
    "    f = np.zeros(D)\n",
    "    A = []\n",
    "    b = []\n",
    "    c = []\n",
    "    d = []\n",
    "\n",
    "    for i in range(W.shape[0]):\n",
    "        A.append(np.zeros((1, D)))\n",
    "        b.append(np.zeros(1))\n",
    "        c.append(W[i,:])\n",
    "        d.append(np.zeros(1))\n",
    "    \n",
    "    A.append(np.eye(D))\n",
    "    b.append((vi-vj).ravel())\n",
    "    c.append(np.zeros(D))\n",
    "    d.append(eps*np.ones(1))\n",
    "\n",
    "    for i in range(W.shape[0]):\n",
    "        A.append(np.zeros((1, D)))\n",
    "        b.append(np.zeros(1))\n",
    "        c.append(W[i,:])\n",
    "        d.append(np.dot(W[i,:],(vi-vj)))\n",
    "        \n",
    "    # Define and solve the CVXPY problem.\n",
    "    x = cp.Variable(D)\n",
    "    # We use cp.SOC(t, x) to create the SOC constraint ||x||_2 <= t.\n",
    "    soc_constraints = [\n",
    "          cp.SOC(c[i].T @ x + d[i], A[i] @ x + b[i]) for i in range(m)\n",
    "    ]\n",
    "    prob = cp.Problem(cp.Minimize(f.T@x),\n",
    "                  soc_constraints)\n",
    "    prob.solve()\n",
    "\n",
    "    \"\"\"\n",
    "    # Print result.\n",
    "    print(\"The optimal value is\", prob.value)\n",
    "    print(\"A solution x is\")\n",
    "    print(x.value)\n",
    "    print(x.value is not None)\n",
    "    for i in range(m):\n",
    "        print(\"SOC constraint %i dual variable solution\" % i)\n",
    "        print(soc_constraints[i].dual_value)\n",
    "    \"\"\"     \n",
    "    return x.value is not None\n",
    "\n",
    "\n",
    "def is_covered(vi, vj, eps, W):\n",
    "    \"\"\"\n",
    "    Check if vi is eps covered by vj for cone matrix W \n",
    "    :param vi, vj: (D,1) ndarrays\n",
    "    :param W: An (n_constraint,D) ndarray\n",
    "    :param eps: float\n",
    "    :return: Boolean.\n",
    "    \"\"\"  \n",
    "    if np.dot((vi-vj).T, vi-vj) <= eps**2:\n",
    "        return True\n",
    "    return is_covered_SOCP(vi, vj, eps, W)\n",
    "\n",
    "    \n",
    "def get_pareto_set(mu, W, alpha_vec, return_mask = False):\n",
    "    \"\"\"\n",
    "    Find the indices of Pareto designs (rows of mu)\n",
    "    :param mu: An (n_points, D) array\n",
    "    :param W: (n_constraint,D) ndarray\n",
    "    :param alpha_vec: (n_constraint,1) ndarray of alphas of W\n",
    "    :param return_mask: True to return a mask\n",
    "    :return: An array of indices of pareto-efficient points.\n",
    "        If return_mask is True, this will be an (n_points, ) boolean array\n",
    "        Otherwise it will be a (n_efficient_points, ) integer array of indices.\n",
    "    \"\"\"\n",
    "    is_efficient = np.arange(mu.shape[0])\n",
    "    n_points = mu.shape[0]\n",
    "    next_point_index = 0  # Next index in the is_efficient array to search for\n",
    "    while next_point_index<len(mu):\n",
    "        nondominated_point_mask = np.zeros(mu.shape[0], dtype=bool)\n",
    "        vj = mu[next_point_index].reshape(-1,1)\n",
    "        for i in range(len(mu)):\n",
    "            vi = mu[i].reshape(-1,1)\n",
    "            nondominated_point_mask[i] =  (get_smallmij(vi, vj, W, alpha_vec) == 0) and (get_bigmij(vi, vj, W) > 0)\n",
    "        nondominated_point_mask[next_point_index] = True\n",
    "        is_efficient = is_efficient[nondominated_point_mask]  # Remove dominated points\n",
    "        mu = mu[nondominated_point_mask]\n",
    "        next_point_index = np.sum(nondominated_point_mask[:next_point_index])+1\n",
    "    if return_mask:\n",
    "        is_efficient_mask = np.zeros(n_points, dtype = bool)\n",
    "        is_efficient_mask[is_efficient] = True\n",
    "        return is_efficient_mask\n",
    "    else:\n",
    "        return is_efficient \n",
    "\n",
    "    \n",
    "def get_delta(mu, W, alpha_vec):\n",
    "    \"\"\"\n",
    "    Computes Delta^*_i for each i in [n.points]\n",
    "    :param mu: An (n_points, D) array\n",
    "    :param W: (n_constraint,D) ndarray\n",
    "    :param alpha_vec: (n_constraint,1) ndarray of alphas of W\n",
    "    :return: An (n_points, D) array of Delta^*_i for each i in [n.points]\n",
    "    \"\"\"\n",
    "    n = mu.shape[0]\n",
    "    Delta = np.zeros(n)\n",
    "    for i in range(n):\n",
    "        for j in range(n):\n",
    "            vi = mu[i,:].reshape(-1,1)\n",
    "            vj = mu[j,:].reshape(-1,1)\n",
    "            mij = get_smallmij(vi, vj, W, alpha_vec)\n",
    "            if mij>Delta[i]:\n",
    "                Delta[i] = mij\n",
    "    \n",
    "    return Delta.reshape(-1,1)\n",
    "\n",
    "\n",
    "def get_uncovered_set(p_opt_miss, p_opt_hat, mu, eps, W):\n",
    "    \"\"\"\n",
    "    Check if vi is eps covered by vj for cone matrix W \n",
    "    :param p_opt_hat: ndarray of indices of designs in returned Pareto set\n",
    "    :param p_opt_miss: ndarray of indices of Pareto optimal points not in p_opt_hat\n",
    "    :mu: An (n_points,D) mean reward matrix\n",
    "    :param eps: float\n",
    "    :param W: An (n_constraint,D) ndarray\n",
    "    :return: ndarray of indices of points in p_opt_miss that are not epsilon covered\n",
    "    \"\"\"  \n",
    "    uncovered_set = []\n",
    "    \n",
    "    for i in p_opt_miss:\n",
    "        uncovered = True\n",
    "        for j in p_opt_hat:\n",
    "            if is_covered(mu[i,:].reshape(-1,1), mu[j,:].reshape(-1,1), eps, W):\n",
    "                uncovered = False\n",
    "        \n",
    "        if uncovered:\n",
    "            uncovered_set.append(i)\n",
    "        \n",
    "    return np.array(uncovered_set)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[  2   3   4   5   6   7   8  10  11  12  14  18  27  28  29  30  32  33\n",
      "  34  35  36  37  38  39  40  42  43  44  45  46  49  50  59  61  63  64\n",
      "  66  67  80  81  96 112 128 153 154 155 160 161 162 167 168 174 187]\n",
      "[  2   3   4   5   6   7   8  10  11  12  14  28  29  30  32  38  40  42\n",
      "  43  45  63 160 161 167 168 174]\n",
      "[  2   4   6   7   8  10  12  14 160 167]\n"
     ]
    }
   ],
   "source": [
    "# Generate matrix of inequalities for C_45, C_90, C_135\n",
    "# Obtain indices of designs in true Pareto sets P*_45, P*_90, P*_135\n",
    "\n",
    "theta_45 = np.pi/4\n",
    "W_45_1 = np.array([-np.tan(np.pi/4-theta_45/2), 1])\n",
    "W_45_2 = np.array([+np.tan(np.pi/4+theta_45/2), -1])\n",
    "W_45_1 = W_45_1/np.linalg.norm(W_45_1)\n",
    "W_45_2 = W_45_2/np.linalg.norm(W_45_2)\n",
    "W_45 = np.vstack((W_45_1, W_45_2))\n",
    "\n",
    "W_90 = np.eye(2)\n",
    "\n",
    "theta_135 = 3*np.pi/4\n",
    "W_135_1 = np.array([-np.tan(np.pi/4-theta_135/2), 1])\n",
    "W_135_2 = np.array([-np.tan(np.pi/4+theta_135/2), 1])\n",
    "W_135_1 = W_135_1/np.linalg.norm(W_135_1)\n",
    "W_135_2 = W_135_2/np.linalg.norm(W_135_2)\n",
    "W_135 = np.vstack((W_135_1, W_135_2))\n",
    "\n",
    "alpha_vec_45 = get_alpha_vec(W_45)\n",
    "alpha_vec_90 = get_alpha_vec(W_90)\n",
    "alpha_vec_135 = get_alpha_vec(W_135)\n",
    "\n",
    "p_opt_45 = get_pareto_set(mu, W_45, alpha_vec_45)\n",
    "p_opt_90 = get_pareto_set(mu, W_90, alpha_vec_90)\n",
    "p_opt_135 = get_pareto_set(mu, W_135, alpha_vec_135)\n",
    "\n",
    "# Print indices of designs in true Pareto sets P*_45, P*_90, P*_135\n",
    "\n",
    "print(p_opt_45)\n",
    "print(p_opt_90)\n",
    "print(p_opt_135)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "p_opt_135 subset p_opt_90 subset p_opt_45\n",
      "Out of 206 designs 53 appears in C(pi/4), 26 appears in C(pi/2), 10 appears in C(3pi/4)\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 360x360 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# 1. Sanity check. For theta1 > theta2, P*_theta1 should be a subset of P*_theta2\n",
    "# 2. Print number of designs appearing in each Pareto set\n",
    "# 3. Plot Pareto front for C_45, C_90, C_135\n",
    "\n",
    "if np.setdiff1d(p_opt_135,p_opt_90).size == 0 and np.setdiff1d(p_opt_90,p_opt_45).size == 0:\n",
    "    print(\"p_opt_135 subset p_opt_90 subset p_opt_45\")\n",
    "else:\n",
    "    print(\"ERROR. p_opt_135 subset p_opt_90 subset p_opt_45 DOES NOT HOLD\") \n",
    "\n",
    "p_opt_45_unique = np.setdiff1d(p_opt_45,p_opt_90)\n",
    "p_opt_90_unique = np.setdiff1d(p_opt_90,p_opt_135)\n",
    "\n",
    "print(\"Out of {} designs {} appears in C(pi/4), {} appears in C(pi/2), {} appears in C(3pi/4)\".format(mu.shape[0], p_opt_45.shape[0], p_opt_90.shape[0], p_opt_135.shape[0]))\n",
    "\n",
    "fig, ax = plt.subplots(figsize=(5, 5))\n",
    "\n",
    "ax.scatter(mu[np.delete(np.arange(mu.shape[0]), p_opt_45),0], mu[np.delete(np.arange(mu.shape[0]), p_opt_45) ,1], c='gray', alpha=0.5)\n",
    "ax.scatter(mu[p_opt_135,0], mu[p_opt_135,1], c='tab:green',label=r'$i \\in P^*_{3\\pi/4}$', alpha=0.5)\n",
    "ax.scatter(mu[p_opt_90_unique,0], mu[p_opt_90_unique ,1], c='tab:blue', label=r'$i \\in  P^*_{\\pi/2} \\setminus P^*_{3\\pi/4}$', alpha=0.5)\n",
    "ax.scatter(mu[p_opt_45_unique,0], mu[p_opt_45_unique ,1], c='tab:orange', label=r'$i \\in P^*_{\\pi/4} \\setminus P^*_{\\pi/2}$', alpha=0.5)\n",
    "\n",
    "ax.set_xlabel(r'$\\mu^1$')\n",
    "ax.set_ylabel(r'$\\mu^2$')\n",
    "ax.set_xlim(-18,-5)\n",
    "ax.set_ylim(2,15)\n",
    "ax.legend()\n",
    "plt.savefig('paretosets.pdf')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Compute Delta^*_i\n",
    "\n",
    "Delta_45 = get_delta(mu, W_45, alpha_vec_45)\n",
    "Delta_90 = get_delta(mu, W_90, alpha_vec_90)\n",
    "Delta_135 = get_delta(mu, W_135, alpha_vec_135)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>mu_1</th>\n",
       "      <th>mu_2</th>\n",
       "      <th>Delta_45</th>\n",
       "      <th>Delta_90</th>\n",
       "      <th>Delta_135</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>count</th>\n",
       "      <td>206.000000</td>\n",
       "      <td>206.000000</td>\n",
       "      <td>153.000000</td>\n",
       "      <td>180.000000</td>\n",
       "      <td>196.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>mean</th>\n",
       "      <td>-12.136967</td>\n",
       "      <td>9.424007</td>\n",
       "      <td>0.666476</td>\n",
       "      <td>0.905822</td>\n",
       "      <td>1.342783</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>std</th>\n",
       "      <td>2.066398</td>\n",
       "      <td>2.155770</td>\n",
       "      <td>0.520270</td>\n",
       "      <td>0.710753</td>\n",
       "      <td>0.869483</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>min</th>\n",
       "      <td>-16.248817</td>\n",
       "      <td>2.858161</td>\n",
       "      <td>0.001360</td>\n",
       "      <td>0.003777</td>\n",
       "      <td>0.018363</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>25%</th>\n",
       "      <td>-13.756088</td>\n",
       "      <td>7.743677</td>\n",
       "      <td>0.264716</td>\n",
       "      <td>0.292774</td>\n",
       "      <td>0.751456</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>50%</th>\n",
       "      <td>-11.979960</td>\n",
       "      <td>9.691435</td>\n",
       "      <td>0.599548</td>\n",
       "      <td>0.831458</td>\n",
       "      <td>1.216701</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>75%</th>\n",
       "      <td>-10.470902</td>\n",
       "      <td>10.911977</td>\n",
       "      <td>0.974929</td>\n",
       "      <td>1.306122</td>\n",
       "      <td>1.845063</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>max</th>\n",
       "      <td>-7.087463</td>\n",
       "      <td>14.716642</td>\n",
       "      <td>2.576346</td>\n",
       "      <td>3.543719</td>\n",
       "      <td>4.726188</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "             mu_1        mu_2    Delta_45    Delta_90   Delta_135\n",
       "count  206.000000  206.000000  153.000000  180.000000  196.000000\n",
       "mean   -12.136967    9.424007    0.666476    0.905822    1.342783\n",
       "std      2.066398    2.155770    0.520270    0.710753    0.869483\n",
       "min    -16.248817    2.858161    0.001360    0.003777    0.018363\n",
       "25%    -13.756088    7.743677    0.264716    0.292774    0.751456\n",
       "50%    -11.979960    9.691435    0.599548    0.831458    1.216701\n",
       "75%    -10.470902   10.911977    0.974929    1.306122    1.845063\n",
       "max     -7.087463   14.716642    2.576346    3.543719    4.726188"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Descriptive statistics of Pareto suboptimal designs\n",
    "\n",
    "mu_describe = pd.DataFrame(np.hstack((mu, Delta_45, Delta_90, Delta_135)), columns = ['mu_1', 'mu_2', 'Delta_45', 'Delta_90', 'Delta_135'])\n",
    "mu_describe.mask(mu_describe == 0).describe()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Simulation parameters\n",
    "sigma = 1\n",
    "delta = 0.01\n",
    "K = mu.shape[0]\n",
    "c = 1 + np.sqrt(2)\n",
    "D = 2\n",
    "eps = np.array([0.001, 0.01, 0.1])\n",
    "\n",
    "# Theoretical value of number of samples per arm (for theta = pi/2)\n",
    "l = np.ceil( 4*((c*sigma/eps)**2)*np.log(4*D/(2*delta/(K*(K-1)))))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Simulation model\n",
    "\n",
    "seed = 12345\n",
    "np.random.seed(seed) \n",
    "\n",
    "eval_num = np.array([100, 1000, 10000, 100000])\n",
    "nrun = 100\n",
    "nsample = eval_num.shape[0]\n",
    "noisemat = sigma * np.random.randn(nrun,nsample,K,D)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Compute epsilon independent results\n",
    "\n",
    "noisemat_interval = noisemat * np.sqrt(np.hstack((eval_num[0],np.diff(eval_num))))[np.newaxis,:,np.newaxis,np.newaxis]\n",
    "noisemat_avg = np.cumsum(noisemat_interval,axis=1)/eval_num[np.newaxis,:,np.newaxis,np.newaxis]\n",
    "\n",
    "mu_hat = mu[np.newaxis,np.newaxis,:,:] + noisemat_avg\n",
    "\n",
    "# p_optmiss: number of i in P* but notin P\n",
    "# p_subopt_45_cnt: number of i in P such that Delta*_i > epsilon\n",
    "\n",
    "p_optmiss_45_cnt = np.zeros((nrun, eval_num.shape[0]))\n",
    "p_subopt_45_cnt = np.zeros((nrun, eval_num.shape[0]))\n",
    "\n",
    "p_optmiss_90_cnt = np.zeros((nrun, eval_num.shape[0]))\n",
    "p_subopt_90_cnt = np.zeros((nrun, eval_num.shape[0]))\n",
    "\n",
    "p_optmiss_135_cnt = np.zeros((nrun, eval_num.shape[0]))\n",
    "p_subopt_135_cnt = np.zeros((nrun, eval_num.shape[0]))\n",
    "\n",
    "P_dict = {}\n",
    "\n",
    "for i in range(nrun):\n",
    "    for j in range(eval_num.shape[0]):\n",
    "        p_opt_45_hat = get_pareto_set(mu_hat[i,j,:,:], W_45, alpha_vec_45)\n",
    "        p_opt_90_hat = get_pareto_set(mu_hat[i,j,:,:], W_90, alpha_vec_90)\n",
    "        p_opt_135_hat = get_pareto_set(mu_hat[i,j,:,:], W_135, alpha_vec_135)\n",
    "        \n",
    "        p_subopt_45_cnt[i,j] = np.setdiff1d(p_opt_45_hat, p_opt_45).shape[0]\n",
    "        p_subopt_90_cnt[i,j] = np.setdiff1d(p_opt_90_hat, p_opt_90).shape[0]\n",
    "        p_subopt_135_cnt[i,j] = np.setdiff1d(p_opt_135_hat, p_opt_135).shape[0]\n",
    "        \n",
    "        p_optmiss_45_cnt[i,j] = np.setdiff1d(p_opt_45, p_opt_45_hat).shape[0]\n",
    "        p_optmiss_90_cnt[i,j] = np.setdiff1d(p_opt_90, p_opt_90_hat).shape[0]\n",
    "        p_optmiss_135_cnt[i,j] = np.setdiff1d(p_opt_135, p_opt_135_hat).shape[0]\n",
    "        \n",
    "        P_dict[(i,j,45)] = p_opt_45_hat\n",
    "        P_dict[(i,j,90)] = p_opt_90_hat\n",
    "        P_dict[(i,j,135)] = p_opt_135_hat\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "np.savez('results_final_r100.npz', \n",
    "         P_dict = P_dict, \n",
    "         p_subopt_45_cnt = p_subopt_45_cnt, \n",
    "         p_subopt_90_cnt = p_subopt_90_cnt, \n",
    "         p_subopt_135_cnt = p_subopt_135_cnt, \n",
    "         p_optmiss_45_cnt = p_optmiss_45_cnt,\n",
    "         p_optmiss_90_cnt = p_optmiss_90_cnt,\n",
    "         p_optmiss_135_cnt = p_optmiss_135_cnt)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Compute the number of times designs in P satisfy success condition\n",
    "\n",
    "# Number of Pareto optimal points that fail condition 1\n",
    "fail1_45_cnt = np.zeros((nrun, eval_num.shape[0], eps.shape[0])) \n",
    "fail1_90_cnt = np.zeros((nrun, eval_num.shape[0], eps.shape[0]))\n",
    "fail1_135_cnt = np.zeros((nrun, eval_num.shape[0], eps.shape[0]))\n",
    "\n",
    "# Number of returned suboptimal points that fail condition 2\n",
    "fail2_45_cnt = np.zeros((nrun, eval_num.shape[0], eps.shape[0])) \n",
    "fail2_90_cnt = np.zeros((nrun, eval_num.shape[0], eps.shape[0]))\n",
    "fail2_135_cnt = np.zeros((nrun, eval_num.shape[0], eps.shape[0]))\n",
    "\n",
    "for i in range(nrun):\n",
    "    for j in range(eval_num.shape[0]):\n",
    "        \n",
    "        p_opt_45_hat = P_dict[(i,j,45)]\n",
    "        p_opt_90_hat = P_dict[(i,j,90)]\n",
    "        p_opt_135_hat = P_dict[(i,j,135)]\n",
    "        \n",
    "        fail2_45_cnt[i,j,:] = np.count_nonzero(Delta_45[p_opt_45_hat] > eps, axis=0)\n",
    "        fail2_90_cnt[i,j,:] = np.count_nonzero(Delta_90[p_opt_90_hat] > eps, axis=0)\n",
    "        fail2_135_cnt[i,j,:] = np.count_nonzero(Delta_135[p_opt_135_hat] > eps, axis=0)\n",
    "        \n",
    "        p_optmiss_45 = np.setdiff1d(p_opt_45, p_opt_45_hat)\n",
    "        p_optmiss_90 = np.setdiff1d(p_opt_90, p_opt_90_hat)\n",
    "        p_optmiss_135 = np.setdiff1d(p_opt_135, p_opt_135_hat)\n",
    "        \n",
    "        for k in range(eps.shape[0]):\n",
    "    \n",
    "            fail1_points_45 = get_uncovered_set(p_optmiss_45, p_opt_45_hat, mu, eps[k], W_45)\n",
    "            fail1_points_90 = get_uncovered_set(p_optmiss_90, p_opt_90_hat, mu, eps[k], W_90)\n",
    "            fail1_points_135 = get_uncovered_set(p_optmiss_135, p_opt_135_hat, mu, eps[k], W_135)\n",
    "            \n",
    "            fail1_45_cnt[i,j,k] = fail1_points_45.shape[0]\n",
    "            fail1_90_cnt[i,j,k] = fail1_points_90.shape[0]\n",
    "            fail1_135_cnt[i,j,k] = fail1_points_135.shape[0]\n",
    "            \n",
    "success_rate_45 = np.average(((fail1_45_cnt == 0) & (fail2_45_cnt == 0)).astype(int), axis=0)\n",
    "success_rate_90 = np.average(((fail1_90_cnt == 0) & (fail2_90_cnt == 0)).astype(int), axis=0)\n",
    "success_rate_135 = np.average(((fail1_135_cnt == 0) & (fail2_135_cnt == 0)).astype(int), axis=0)            \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th>SR 45</th>\n",
       "      <th>SR 90</th>\n",
       "      <th>SR 135</th>\n",
       "      <th>NF1 45</th>\n",
       "      <th>NF1 90</th>\n",
       "      <th>NF1 135</th>\n",
       "      <th>NF2 45</th>\n",
       "      <th>NF2 90</th>\n",
       "      <th>NF2 135</th>\n",
       "      <th>PM 45</th>\n",
       "      <th>PM 90</th>\n",
       "      <th>PM 135</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th rowspan=\"3\" valign=\"top\">100</th>\n",
       "      <th>0.001</th>\n",
       "      <td>0.000</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.000</td>\n",
       "      <td>12.440</td>\n",
       "      <td>7.610</td>\n",
       "      <td>1.830</td>\n",
       "      <td>9.260</td>\n",
       "      <td>7.070</td>\n",
       "      <td>2.520</td>\n",
       "      <td>0.248</td>\n",
       "      <td>0.293</td>\n",
       "      <td>0.183</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>0.010</th>\n",
       "      <td>0.000</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.000</td>\n",
       "      <td>11.520</td>\n",
       "      <td>6.870</td>\n",
       "      <td>1.830</td>\n",
       "      <td>7.440</td>\n",
       "      <td>6.080</td>\n",
       "      <td>2.520</td>\n",
       "      <td>0.248</td>\n",
       "      <td>0.293</td>\n",
       "      <td>0.183</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>0.100</th>\n",
       "      <td>1.000</td>\n",
       "      <td>7.000</td>\n",
       "      <td>27.000</td>\n",
       "      <td>4.220</td>\n",
       "      <td>1.210</td>\n",
       "      <td>0.630</td>\n",
       "      <td>1.270</td>\n",
       "      <td>0.980</td>\n",
       "      <td>0.830</td>\n",
       "      <td>0.248</td>\n",
       "      <td>0.293</td>\n",
       "      <td>0.183</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th rowspan=\"3\" valign=\"top\">1000</th>\n",
       "      <th>0.001</th>\n",
       "      <td>0.000</td>\n",
       "      <td>0.000</td>\n",
       "      <td>29.000</td>\n",
       "      <td>4.450</td>\n",
       "      <td>3.330</td>\n",
       "      <td>0.320</td>\n",
       "      <td>5.780</td>\n",
       "      <td>3.720</td>\n",
       "      <td>0.890</td>\n",
       "      <td>0.095</td>\n",
       "      <td>0.128</td>\n",
       "      <td>0.032</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>0.010</th>\n",
       "      <td>0.000</td>\n",
       "      <td>0.000</td>\n",
       "      <td>29.000</td>\n",
       "      <td>3.680</td>\n",
       "      <td>2.730</td>\n",
       "      <td>0.320</td>\n",
       "      <td>3.570</td>\n",
       "      <td>2.400</td>\n",
       "      <td>0.890</td>\n",
       "      <td>0.095</td>\n",
       "      <td>0.128</td>\n",
       "      <td>0.032</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>0.100</th>\n",
       "      <td>78.000</td>\n",
       "      <td>99.000</td>\n",
       "      <td>100.000</td>\n",
       "      <td>0.180</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.060</td>\n",
       "      <td>0.010</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.095</td>\n",
       "      <td>0.128</td>\n",
       "      <td>0.032</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th rowspan=\"3\" valign=\"top\">10000</th>\n",
       "      <th>0.001</th>\n",
       "      <td>1.000</td>\n",
       "      <td>3.000</td>\n",
       "      <td>85.000</td>\n",
       "      <td>1.330</td>\n",
       "      <td>1.060</td>\n",
       "      <td>0.000</td>\n",
       "      <td>2.540</td>\n",
       "      <td>1.880</td>\n",
       "      <td>0.150</td>\n",
       "      <td>0.034</td>\n",
       "      <td>0.041</td>\n",
       "      <td>0.000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>0.010</th>\n",
       "      <td>22.000</td>\n",
       "      <td>24.000</td>\n",
       "      <td>85.000</td>\n",
       "      <td>0.630</td>\n",
       "      <td>0.770</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.870</td>\n",
       "      <td>0.570</td>\n",
       "      <td>0.150</td>\n",
       "      <td>0.034</td>\n",
       "      <td>0.041</td>\n",
       "      <td>0.000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>0.100</th>\n",
       "      <td>100.000</td>\n",
       "      <td>100.000</td>\n",
       "      <td>100.000</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.034</td>\n",
       "      <td>0.041</td>\n",
       "      <td>0.000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th rowspan=\"3\" valign=\"top\">100000</th>\n",
       "      <th>0.001</th>\n",
       "      <td>17.000</td>\n",
       "      <td>55.000</td>\n",
       "      <td>100.000</td>\n",
       "      <td>0.240</td>\n",
       "      <td>0.060</td>\n",
       "      <td>0.000</td>\n",
       "      <td>1.100</td>\n",
       "      <td>0.440</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.012</td>\n",
       "      <td>0.002</td>\n",
       "      <td>0.000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>0.010</th>\n",
       "      <td>100.000</td>\n",
       "      <td>99.000</td>\n",
       "      <td>100.000</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.010</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.012</td>\n",
       "      <td>0.002</td>\n",
       "      <td>0.000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>0.100</th>\n",
       "      <td>100.000</td>\n",
       "      <td>100.000</td>\n",
       "      <td>100.000</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.000</td>\n",
       "      <td>0.012</td>\n",
       "      <td>0.002</td>\n",
       "      <td>0.000</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "               SR 45   SR 90  SR 135  NF1 45  NF1 90  NF1 135  NF2 45  NF2 90  \\\n",
       "100    0.001   0.000   0.000   0.000  12.440   7.610    1.830   9.260   7.070   \n",
       "       0.010   0.000   0.000   0.000  11.520   6.870    1.830   7.440   6.080   \n",
       "       0.100   1.000   7.000  27.000   4.220   1.210    0.630   1.270   0.980   \n",
       "1000   0.001   0.000   0.000  29.000   4.450   3.330    0.320   5.780   3.720   \n",
       "       0.010   0.000   0.000  29.000   3.680   2.730    0.320   3.570   2.400   \n",
       "       0.100  78.000  99.000 100.000   0.180   0.000    0.000   0.060   0.010   \n",
       "10000  0.001   1.000   3.000  85.000   1.330   1.060    0.000   2.540   1.880   \n",
       "       0.010  22.000  24.000  85.000   0.630   0.770    0.000   0.870   0.570   \n",
       "       0.100 100.000 100.000 100.000   0.000   0.000    0.000   0.000   0.000   \n",
       "100000 0.001  17.000  55.000 100.000   0.240   0.060    0.000   1.100   0.440   \n",
       "       0.010 100.000  99.000 100.000   0.000   0.000    0.000   0.000   0.010   \n",
       "       0.100 100.000 100.000 100.000   0.000   0.000    0.000   0.000   0.000   \n",
       "\n",
       "              NF2 135  PM 45  PM 90  PM 135  \n",
       "100    0.001    2.520  0.248  0.293   0.183  \n",
       "       0.010    2.520  0.248  0.293   0.183  \n",
       "       0.100    0.830  0.248  0.293   0.183  \n",
       "1000   0.001    0.890  0.095  0.128   0.032  \n",
       "       0.010    0.890  0.095  0.128   0.032  \n",
       "       0.100    0.000  0.095  0.128   0.032  \n",
       "10000  0.001    0.150  0.034  0.041   0.000  \n",
       "       0.010    0.150  0.034  0.041   0.000  \n",
       "       0.100    0.000  0.034  0.041   0.000  \n",
       "100000 0.001    0.000  0.012  0.002   0.000  \n",
       "       0.010    0.000  0.012  0.002   0.000  \n",
       "       0.100    0.000  0.012  0.002   0.000  "
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>0</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0.0010</th>\n",
       "      <td>387994913</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>0.0100</th>\n",
       "      <td>3879950</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>0.1000</th>\n",
       "      <td>38800</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "                0\n",
       "0.0010  387994913\n",
       "0.0100    3879950\n",
       "0.1000      38800"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Plot results\n",
    "\n",
    "index = [[num for num in eval_num for i in range(eps.shape[0])], list(eps) * eval_num.shape[0]]\n",
    "columns = ['SR 45', 'SR 90', 'SR 135', 'NF1 45', 'NF1 90', 'NF1 135', 'NF2 45', 'NF2 90', 'NF2 135']\n",
    "test_df = pd.DataFrame(np.random.rand(eps.shape[0]*eval_num.shape[0], len(columns)), index, columns)\n",
    "\n",
    "test_df['SR 45'] = success_rate_45.flatten()*100\n",
    "test_df['SR 90'] = success_rate_90.flatten()*100\n",
    "test_df['SR 135'] = success_rate_135.flatten()*100\n",
    "\n",
    "test_df['NF1 45'] = np.average(fail1_45_cnt, axis=0).flatten()\n",
    "test_df['NF1 90'] = np.average(fail1_90_cnt, axis=0).flatten()\n",
    "test_df['NF1 135'] = np.average(fail1_135_cnt, axis=0).flatten()\n",
    "\n",
    "test_df['NF2 45'] = np.average(fail2_45_cnt, axis=0).flatten()\n",
    "test_df['NF2 90'] = np.average(fail2_90_cnt, axis=0).flatten()\n",
    "test_df['NF2 135'] = np.average(fail2_135_cnt, axis=0).flatten()\n",
    "\n",
    "test_df['PM 45'] = [num for num in np.average(p_optmiss_45_cnt, axis=0)/p_opt_45.shape[0] for i in range(eps.shape[0])]\n",
    "test_df['PM 90'] = [num for num in np.average(p_optmiss_90_cnt, axis=0)/p_opt_90.shape[0] for i in range(eps.shape[0])]\n",
    "test_df['PM 135'] = [num for num in np.average(p_optmiss_135_cnt, axis=0)/p_opt_135.shape[0] for i in range(eps.shape[0])]\n",
    "\n",
    "pd.options.display.float_format = '{:.3f}'.format\n",
    "display(test_df)\n",
    "\n",
    "pd.options.display.float_format = '{:.4f}'.format\n",
    "sample_df = pd.DataFrame(l.astype(int), index = list(eps))\n",
    "display(sample_df)\n",
    "\n",
    "# SR theta: (in %) Success rate for C_theta\n",
    "# NF1 theta: Average number of returned designs that violate success condition 1\n",
    "# NF2 theta: Average number of returned designs that violate success condition 2\n",
    "# PM theta: Average percentage of points in P^* that are not in P"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "np.savez('results_final_r100_epsdep.npz', \n",
    "         fail1_45_cnt = fail1_45_cnt, \n",
    "         fail1_90_cnt = fail1_90_cnt, \n",
    "         fail1_135_cnt = fail1_135_cnt, \n",
    "         fail2_45_cnt = fail2_45_cnt, \n",
    "         fail2_90_cnt = fail2_90_cnt,\n",
    "         fail2_135_cnt = fail2_135_cnt)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\\begin{table}\n",
      "\\centering\n",
      "\\label{tbl:theoretical_l}\n",
      "\\begin{tabular}{lr}\n",
      "\\toprule\n",
      "{} &          0 \\\\\n",
      "\\midrule\n",
      "0.0010 &  387994913 \\\\\n",
      "0.0100 &    3879950 \\\\\n",
      "0.1000 &      38800 \\\\\n",
      "\\bottomrule\n",
      "\\end{tabular}\n",
      "\\end{table}\n",
      "\n",
      "\\begin{table}\n",
      "\\centering\n",
      "\\label{tbl:gapsofsuboptimals}\n",
      "\\begin{tabular}{lrrrrr}\n",
      "\\toprule\n",
      "{} &    mu\\_1 &    mu\\_2 &  Delta\\_45 &  Delta\\_90 &  Delta\\_135 \\\\\n",
      "\\midrule\n",
      "count & 206.000 & 206.000 &   153.000 &   180.000 &    196.000 \\\\\n",
      "mean  & -12.137 &   9.424 &     0.666 &     0.906 &      1.343 \\\\\n",
      "std   &   2.066 &   2.156 &     0.520 &     0.711 &      0.869 \\\\\n",
      "min   & -16.249 &   2.858 &     0.001 &     0.004 &      0.018 \\\\\n",
      "max   &  -7.087 &  14.717 &     2.576 &     3.544 &      4.726 \\\\\n",
      "\\bottomrule\n",
      "\\end{tabular}\n",
      "\\end{table}\n",
      "\n",
      "\\begin{table}\n",
      "\\centering\n",
      "\\label{tbl:ressults}\n",
      "\\begin{tabular}{llrrr}\n",
      "\\toprule\n",
      "       &        &  SR 45 &  SR 90 &  SR 135 \\\\\n",
      "\\midrule\n",
      "\\multirow{3}{*}{100} & 0.0010 &   0.00 &   0.00 &    0.00 \\\\\n",
      "       & 0.0100 &   0.00 &   0.00 &    0.00 \\\\\n",
      "       & 0.1000 &   1.00 &   7.00 &   27.00 \\\\\n",
      "\\cline{1-5}\n",
      "\\multirow{3}{*}{1000} & 0.0010 &   0.00 &   0.00 &   29.00 \\\\\n",
      "       & 0.0100 &   0.00 &   0.00 &   29.00 \\\\\n",
      "       & 0.1000 &  78.00 &  99.00 &  100.00 \\\\\n",
      "\\cline{1-5}\n",
      "\\multirow{3}{*}{10000} & 0.0010 &   1.00 &   3.00 &   85.00 \\\\\n",
      "       & 0.0100 &  22.00 &  24.00 &   85.00 \\\\\n",
      "       & 0.1000 & 100.00 & 100.00 &  100.00 \\\\\n",
      "\\cline{1-5}\n",
      "\\multirow{3}{*}{100000} & 0.0010 &  17.00 &  55.00 &  100.00 \\\\\n",
      "       & 0.0100 & 100.00 &  99.00 &  100.00 \\\\\n",
      "       & 0.1000 & 100.00 & 100.00 &  100.00 \\\\\n",
      "\\bottomrule\n",
      "\\end{tabular}\n",
      "\\end{table}\n",
      "\n",
      "\\begin{table}\n",
      "\\centering\n",
      "\\label{tbl:ressults}\n",
      "\\begin{tabular}{llrrrrrrrrrrrr}\n",
      "\\toprule\n",
      "       &        &  SR 45 &  SR 90 &  SR 135 &  NF1 45 &  NF1 90 &  NF1 135 &  NF2 45 &  NF2 90 &  NF2 135 &  PM 45 &  PM 90 &  PM 135 \\\\\n",
      "\\midrule\n",
      "\\multirow{3}{*}{100} & 0.0010 &   0.00 &   0.00 &    0.00 &   12.44 &    7.61 &     1.83 &    9.26 &    7.07 &     2.52 &   0.25 &   0.29 &    0.18 \\\\\n",
      "       & 0.0100 &   0.00 &   0.00 &    0.00 &   11.52 &    6.87 &     1.83 &    7.44 &    6.08 &     2.52 &   0.25 &   0.29 &    0.18 \\\\\n",
      "       & 0.1000 &   1.00 &   7.00 &   27.00 &    4.22 &    1.21 &     0.63 &    1.27 &    0.98 &     0.83 &   0.25 &   0.29 &    0.18 \\\\\n",
      "\\cline{1-14}\n",
      "\\multirow{3}{*}{1000} & 0.0010 &   0.00 &   0.00 &   29.00 &    4.45 &    3.33 &     0.32 &    5.78 &    3.72 &     0.89 &   0.10 &   0.13 &    0.03 \\\\\n",
      "       & 0.0100 &   0.00 &   0.00 &   29.00 &    3.68 &    2.73 &     0.32 &    3.57 &    2.40 &     0.89 &   0.10 &   0.13 &    0.03 \\\\\n",
      "       & 0.1000 &  78.00 &  99.00 &  100.00 &    0.18 &    0.00 &     0.00 &    0.06 &    0.01 &     0.00 &   0.10 &   0.13 &    0.03 \\\\\n",
      "\\cline{1-14}\n",
      "\\multirow{3}{*}{10000} & 0.0010 &   1.00 &   3.00 &   85.00 &    1.33 &    1.06 &     0.00 &    2.54 &    1.88 &     0.15 &   0.03 &   0.04 &    0.00 \\\\\n",
      "       & 0.0100 &  22.00 &  24.00 &   85.00 &    0.63 &    0.77 &     0.00 &    0.87 &    0.57 &     0.15 &   0.03 &   0.04 &    0.00 \\\\\n",
      "       & 0.1000 & 100.00 & 100.00 &  100.00 &    0.00 &    0.00 &     0.00 &    0.00 &    0.00 &     0.00 &   0.03 &   0.04 &    0.00 \\\\\n",
      "\\cline{1-14}\n",
      "\\multirow{3}{*}{100000} & 0.0010 &  17.00 &  55.00 &  100.00 &    0.24 &    0.06 &     0.00 &    1.10 &    0.44 &     0.00 &   0.01 &   0.00 &    0.00 \\\\\n",
      "       & 0.0100 & 100.00 &  99.00 &  100.00 &    0.00 &    0.00 &     0.00 &    0.00 &    0.01 &     0.00 &   0.01 &   0.00 &    0.00 \\\\\n",
      "       & 0.1000 & 100.00 & 100.00 &  100.00 &    0.00 &    0.00 &     0.00 &    0.00 &    0.00 &     0.00 &   0.01 &   0.00 &    0.00 \\\\\n",
      "\\bottomrule\n",
      "\\end{tabular}\n",
      "\\end{table}\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Results in Latex tables\n",
    "print(sample_df.to_latex(float_format=\"%.3f\", label = \"tbl:theoretical_l\"))\n",
    "\n",
    "mu_table = mu_describe.mask(mu_describe == 0).describe().iloc[[0,1,2,3,7],:]\n",
    "print(mu_table.to_latex(float_format=\"%.3f\", label = \"tbl:gapsofsuboptimals\"))\n",
    "\n",
    "\n",
    "print(test_df[[\"SR 45\", \"SR 90\", \"SR 135\"]].to_latex(float_format=\"%.2f\", label = \"tbl:ressults\", multirow = True))\n",
    "\n",
    "print(test_df.to_latex(float_format=\"%.2f\", label = \"tbl:ressults\", multirow = True))"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "VectorOpt",
   "language": "python",
   "name": "vectoropt"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
